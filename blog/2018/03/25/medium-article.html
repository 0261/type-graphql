<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GraphQL + TypeScript = TypeGraphQL · TypeGraphQL</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="GraphQL + TypeScript = TypeGraphQL · TypeGraphQL"/><meta property="og:type" content="website"/><meta property="og:url" content="https://19majkel94.github.io/type-graphql/blog/2018/03/25/medium-article.html"/><meta property="og:description" content="We all love GraphQL! It’s so great and solves many problems that we have with REST API, like overfetching and underfetching. But developing a GraphQL API in Node.js with TypeScript is sometimes a bit of pain."/><link rel="shortcut icon" href="/type-graphql/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css"/><link rel="alternate" type="application/atom+xml" href="https://19majkel94.github.io/blog/atom.xml" title="TypeGraphQL Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://19majkel94.github.io/blog/feed.xml" title="TypeGraphQL Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/type-graphql/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/type-graphql/"><img class="logo" src="/type-graphql/img/logo.png"/><h2 class="headerTitle">TypeGraphQL</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/type-graphql/docs/introduction.html" target="_self">Docs</a></li><li class=""><a href="/type-graphql/docs/examples.html" target="_self">Examples</a></li><li class=""><a href="/type-graphql/docs/faq.html" target="_self">FAQ</a></li><li class="siteNavGroupActive"><a href="/type-graphql/blog" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li class=""><a href="https://github.com/19majkel94/type-graphql" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Recent Posts</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Recent Posts</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/type-graphql/blog/2018/03/25/medium-article.html">GraphQL + TypeScript = TypeGraphQL</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer documentContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1><a href="/type-graphql/blog/2018/03/25/medium-article.html">GraphQL + TypeScript = TypeGraphQL</a></h1><p class="post-meta">March 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/19majkel94" target="_blank">Michał Lytek</a></p><div class="authorPhoto"><a href="https://github.com/19majkel94" target="_blank"><img src="/type-graphql/img/author.jpg"/></a></div></div></header><div><span><p>We all love GraphQL! It’s so great and solves many problems that we have with REST API, like overfetching and underfetching. But developing a GraphQL API in Node.js with TypeScript is sometimes a bit of pain.</p>
<p><strong>TypeGraphQL</strong> makes that process enjoyable, i.a. by defining the schema using only classes and a bit of decorators magic.</p>
<!--truncate-->
<p><img src="/type-graphql/blog/assets/logo_mini.png" alt="type-graphql-logo"></p>
<h2><a class="anchor" aria-hidden="true" id="motivation"></a><a href="#motivation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Motivation</h2>
<p>As I mentioned, developing a GraphQL API in Node.js with TypeScript might be a painful process. Why? Let’s take a look at the steps we usually have to make.</p>
<p>At first, we create the all the schema types in SDL. We also create our data models using ORM classes, which represents our db entities. Then we start to write resolvers for our queries, mutations and fields but this force us to begin with creating TS interfaces for all arguments and inputs or even object types. And after that we can actually implements the resolvers, using weird generic signatures, e.g.:</p>
<pre><code class="hljs css typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> recipesResolver: GraphQLFieldResolver&lt;<span class="hljs-built_in">void</span>, Context, RecipesArgs&gt; =
  <span class="hljs-keyword">async</span> (_, args) =&gt; {
    <span class="hljs-comment">// stuffs like validation, auth checking, getting from container</span>
    <span class="hljs-comment">// and our business logic, e.g.:</span>
    <span class="hljs-keyword">const</span> repository = getRepository(Recipe);
    <span class="hljs-keyword">return</span> repository.find();
  }
</code></pre>
<p>The biggest problem is the rendundancy in our codebase, that makes difficult to keep this things in sync. To add new field to our entity, we have to jump through all the files — modify entity class, then modify part of the schema and then update the interface. The same goes with inputs or arguments, it’s easy to forget to update one or make a mistake with the type. Also, what if we’ve made a typo in field name? The rename feature (F2) won’t work correctly.</p>
<p><strong>TypeGraphQL</strong> comes to address this issues, based on experience from over a dozen months of developing GraphQL APIs in TypeScript. The main idea is to have only one source of truth by defining the schema using classes and a bit of decorators help. Additional features like dependency injection, validation or auth guards helps with common task that normally we would have to handle by ourselves.</p>
<h2><a class="anchor" aria-hidden="true" id="getting-started"></a><a href="#getting-started" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting started</h2>
<p>To explore all powerful capabilities of TypeGraphQL, we will create a sample GraphQL API for cooking recipes.</p>
<p>Let’s start with the Recipe type, which is the foundations of our API.
We want to get equivalent of this type described in SDL:</p>
<pre><code class="hljs css graphql"><span class="hljs-keyword">type</span> <span class="hljs-type">Recipe</span> {
  id: <span class="hljs-type">ID</span>!
  title: <span class="hljs-type">String</span>!
  description: <span class="hljs-type">String</span>
  creationDate: <span class="hljs-type">Date</span>!
  ingredients: [<span class="hljs-type">String</span>!]!
}
</code></pre>
<p>So we create the Recipe class with all properties and types:</p>
<pre><code class="hljs css typescript"><span class="hljs-keyword">class</span> Recipe {
  id: <span class="hljs-built_in">string</span>;
  title: <span class="hljs-built_in">string</span>;
  description?: <span class="hljs-built_in">string</span>;
  creationDate: <span class="hljs-built_in">Date</span>;
  ingredients: <span class="hljs-built_in">string</span>[];
}
</code></pre>
<p>Then we annotate the class and it properties with decorators:</p>
<pre><code class="hljs css typescript"><span class="hljs-meta">@ObjectType</span>()
<span class="hljs-keyword">class</span> Recipe {
  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> ID)
  id: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>()
  title: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>({ nullable: <span class="hljs-literal">true</span> })
  description?: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>()
  creationDate: <span class="hljs-built_in">Date</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> [<span class="hljs-built_in">String</span>])
  ingredients: <span class="hljs-built_in">string</span>[];
}
</code></pre>
<p>The detailed rules when to use <code>nullable</code>, <code>array</code> and other options are described in <a href="https://github.com/19majkel94/type-graphql/blob/master/docs/types-and-fields.md">fields and types docs</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="resolvers"></a><a href="#resolvers" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolvers</h3>
<p>After that we want to create typical crud queries and mutation. To do that we create the resolver (controller) class that will have injected RecipeService in constructor:</p>
<pre><code class="hljs css typescript"><span class="hljs-meta">@Resolver</span>(Recipe)
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> recipeService: RecipeService</span>) {}

  <span class="hljs-meta">@Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> Recipe)
  <span class="hljs-keyword">async</span> recipe(<span class="hljs-meta">@Arg</span>(<span class="hljs-string">"id"</span>) id: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">const</span> recipe = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.recipeService.findById(id);
    <span class="hljs-keyword">if</span> (recipe === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RecipeNotFoundError(id);
    }
    <span class="hljs-keyword">return</span> recipe;
  }

  <span class="hljs-meta">@Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [Recipe])
  recipes(<span class="hljs-meta">@Args</span>() { skip, take }: RecipesArgs) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.recipeService.findAll({ skip, take });
  }

  <span class="hljs-meta">@Mutation</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> Recipe)
  <span class="hljs-meta">@Authorized</span>()
  addRecipe(
    <span class="hljs-meta">@Arg</span>(<span class="hljs-string">"newRecipeData"</span>) newRecipeData: NewRecipeInput,
    <span class="hljs-meta">@Ctx</span>(<span class="hljs-string">"user"</span>) user: User,
  ): <span class="hljs-built_in">Promise</span>&lt;Recipe&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.recipeService.addNew({ data: newRecipeData, user });
  }

  <span class="hljs-meta">@Mutation</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> <span class="hljs-built_in">Boolean</span>)
  <span class="hljs-meta">@Authorized</span>(Roles.Admin)
  <span class="hljs-keyword">async</span> removeRecipe(<span class="hljs-meta">@Arg</span>(<span class="hljs-string">"id"</span>) id: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.recipeService.removeById(id);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
}
</code></pre>
<p>We use <code>@Authorized()</code> decorator to restrict access only for authorized users or the one that fulfill the roles requirements. The detailed rules when and why we declare <code>returns =&gt; Recipe</code> functions and others are described in <a href="https://github.com/19majkel94/type-graphql/blob/master/docs/resolvers.md">resolvers docs</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="inputs-and-arguments"></a><a href="#inputs-and-arguments" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inputs and arguments</h3>
<p>Ok, but what are theNewRecipeInput and RecipesArgs? There are of course classes that declares input type and arguments:</p>
<pre><code class="hljs css typescript"><span class="hljs-meta">@InputType</span>()
<span class="hljs-keyword">class</span> NewRecipeDataInput {
  <span class="hljs-meta">@Field</span>()
  <span class="hljs-meta">@MaxLength</span>(<span class="hljs-number">30</span>)
  title: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>({ nullable: <span class="hljs-literal">true</span> })
  <span class="hljs-meta">@Length</span>(<span class="hljs-number">30</span>, <span class="hljs-number">255</span>)
  description?: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> [<span class="hljs-built_in">String</span>])
  <span class="hljs-meta">@MaxArraySize</span>(<span class="hljs-number">30</span>)
  ingredients: <span class="hljs-built_in">string</span>[];
}

<span class="hljs-meta">@ArgsType</span>()
<span class="hljs-keyword">class</span> RecipesArgs {
  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">0</span>)
  skip: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">1</span>) <span class="hljs-meta">@Max</span>(<span class="hljs-number">50</span>)
  take: <span class="hljs-built_in">number</span> = <span class="hljs-number">25</span>;
}
</code></pre>
<p><code>@Length</code>, <code>@Min</code> or <code>@MaxArraySize</code> are decorators from <a href="https://github.com/typestack/class-validator"><code>class-validator</code></a> that automatically perform fields validation in TypeGraphQL.</p>
<h3><a class="anchor" aria-hidden="true" id="building-schema"></a><a href="#building-schema" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building schema</h3>
<p>The last step that we have to do is to actually build the schema from TypeGraphQL definition. We use buildSchema function for this:</p>
<pre><code class="hljs css typescript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">await</span> buildSchema({
  resolvers: [RecipeResolver]
});

<span class="hljs-comment">// ...creating express server or sth</span>
</code></pre>
<p>Et voilà! Now we have fully working GraphQL schema! If we print it, we would receive exactly this:</p>
<pre><code class="hljs css graphql"><span class="hljs-keyword">type</span> <span class="hljs-type">Recipe</span> {
  id: <span class="hljs-type">ID</span>!
  title: <span class="hljs-type">String</span>!
  description: <span class="hljs-type">String</span>
  creationDate: <span class="hljs-type">Date</span>!
  ingredients: [<span class="hljs-type">String</span>!]!
}
<span class="hljs-title">input</span> <span class="hljs-type">NewRecipeInput</span> {
  title: <span class="hljs-type">String</span>!
  description: <span class="hljs-type">String</span>
  ingredients: [<span class="hljs-type">String</span>!]!
}
<span class="hljs-keyword">type</span> <span class="hljs-type">Query</span> {
  recipe(id: <span class="hljs-type">ID</span>!): <span class="hljs-type">Recipe</span>
  recipes(skip: <span class="hljs-type">Int</span>, take: <span class="hljs-type">Int</span>): [<span class="hljs-type">Recipe</span>!]!
}
<span class="hljs-keyword">type</span> <span class="hljs-type">Mutation</span> {
  addRecipe(newRecipeData: <span class="hljs-type">NewRecipeInput</span>!): <span class="hljs-type">Recipe</span>!
  removeRecipe(id: <span class="hljs-type">ID</span>!): <span class="hljs-type">Boolean</span>!
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="want-more"></a><a href="#want-more" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Want more?</h2>
<p>That was only a tip of the iceberg — a very simple example with basic GraphQL types. Do you use interfaces, enums, unions and custom scalars? That’s great because TypeGraphQL fully supports them too!</p>
<p>If you want to see how it looks in more complicated case, you can go to the <a href="https://github.com/19majkel94/type-graphql/blob/master/examples">Examples section</a> where you can find how nice TypeGraphQL integrates with TypeORM. Want to learn about more advanced concepts like authorization checker, inheritance support or field resolvers? Check out the <a href="https://github.com/19majkel94/type-graphql/blob/master/docs">Docs section</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="work-in-progress"></a><a href="#work-in-progress" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Work in progress</h2>
<p>Currently released version is a <strong>MVP</strong> (Minimum Viable Product). It is well tested (95% coverage, 4400 lines of test code) and has 90% of the planned features already implemented. However there’s some work to be done before 1.0.0 release and it’s mostly about documentation (website, api reference and jsdoc).</p>
<p>There are also plans for more features like better TypeORM and dataloader integration or middlewares and custom decorators support — <a href="https://github.com/19majkel94/type-graphql/issues?q=is%3Aissue+is%3Aopen+label%3A%22Enhancement+%3Anew%3A%22">the full list of ideas</a> is available on the GitHub repo. You can also keep track of <a href="https://github.com/19majkel94/type-graphql/projects/1">development’s progress on project board</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="spread-the-word"></a><a href="#spread-the-word" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spread the word</h2>
<p>I strongly encourage you to give it a try and experiment with <strong>TypeGraphQL</strong>.
I promise, it will reduce your codebase by a half or more!</p>
<p>If you find this framework interesting, please <a href="https://github.com/19majkel94/type-graphql">star the GitHub repository</a>, clap for this article and share it on your social media, if you don’t mind.</p>
<p>The more feedback I receive, the more time I will devote to continue the development of TypeGraphQL!</p>
</span></div></div></div><div class="blog-recent"><a class="button" href="/type-graphql/blog">Recent Posts</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/type-graphql/" class="nav-home"><img src="/type-graphql/img/logo.png" alt="TypeGraphQL" width="66" height="58"/></a><div><h5>Docs</h5><a href="/type-graphql/docs/en/introduction.html">Introduction</a><a href="/type-graphql/docs/en/getting-started.html">Getting Started</a><a href="/type-graphql/docs/en/scalars.html">Advanced Guides</a></div><div><h5>Community</h5><a href="https://github.com/19majkel94/type-graphql/issues?utf8=✓&amp;q=is%3Aissue+label%3A&amp;quot;Enhancement+%3Anew%3A&amp;quot;+">Feature requests and proposals</a><a href="https://github.com/19majkel94/type-graphql/issues?q=is%3Aissue+label%3A&amp;quot;Bug+%3Abug%3A&amp;quot;">Issues</a><a href="https://gitter.im/type-graphql/Lobby">Project Chat</a><a href="https://twitter.com/19majkel94" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/type-graphql/blog">Blog</a><a href="https://github.com/19majkel94/type-graphql">GitHub</a><a class="github-button" href="https://github.com/19majkel94/type-graphql" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2018 Michał Lytek</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-117093147-1', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                
                apiKey: '2cf66434100c0e30ca9ff499830e7b77',
                indexName: 'typegraphql',
                inputSelector: '#search_input_react'
              });
            </script></body></html>