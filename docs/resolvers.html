<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Resolvers · TypeGraphQL</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Resolvers · TypeGraphQL"/><meta property="og:type" content="website"/><meta property="og:url" content="https://19majkel94.github.io/type-graphql/index.html"/><meta property="og:description" content="Besides [declaring GraphQL&#x27;s object types](/type-graphql/docs/types-and-fields.html), TypeGraphQL allows to create queries, mutations and field resolvers in an easy way - like a normal class methods, similar to REST controllers in frameworks like Java&#x27;s `Spring`, .NET `Web API` or TypeScript&#x27;s [routing-controllers](https://github.com/typestack/routing-controllers)."/><link rel="shortcut icon" href="/type-graphql/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css"/><link rel="alternate" type="application/atom+xml" href="https://19majkel94.github.io/blog/atom.xml" title="TypeGraphQL Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://19majkel94.github.io/blog/feed.xml" title="TypeGraphQL Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/type-graphql/css/main.css"/></head><body class="sideNavVisible doc separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/type-graphql/"><img class="logo" src="/type-graphql/img/logo.png"/><h2 class="headerTitle">TypeGraphQL</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/type-graphql/docs/introduction.html" target="_self">Docs</a></li><li class=""><a href="/type-graphql/docs/examples.html" target="_self">Examples</a></li><li class=""><a href="/type-graphql/docs/faq.html" target="_self">FAQ</a></li><li class=""><a href="/type-graphql/blog" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li class=""><a href="https://github.com/19majkel94/type-graphql" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Beginner guides</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/type-graphql/docs/introduction.html">What &amp; Why</a></li></ul></div><div class="navGroup navGroupActive"><h3>Beginner guides</h3><ul><li class="navListItem"><a class="navItem" href="/type-graphql/docs/getting-started.html">Getting started</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/types-and-fields.html">Types and fields</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/type-graphql/docs/resolvers.html">Resolvers</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/bootstrap.html">Bootstrapping</a></li></ul></div><div class="navGroup navGroupActive"><h3>Advanced guides</h3><ul><li class="navListItem"><a class="navItem" href="/type-graphql/docs/scalars.html">Scalars</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/enums.html">Enums</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/unions.html">Unions</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/interfaces-and-inheritance.html">Interfaces and inheritance</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/subscriptions.html">Subscriptions</a></li></ul></div><div class="navGroup navGroupActive"><h3>Features</h3><ul><li class="navListItem"><a class="navItem" href="/type-graphql/docs/dependency-injection.html">Dependency injection</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/authorization.html">Authorization</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/validation.html">Validation</a></li><li class="navListItem"><a class="navItem" href="/type-graphql/docs/middlewares.html">Middlewares and guards</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/19majkel94/type-graphql/edit/master/docs/resolvers.md" target="_blank">Edit</a><h1>Resolvers</h1></header><article><div><span><p>Besides <a href="/type-graphql/docs/types-and-fields.html">declaring GraphQL's object types</a>, TypeGraphQL allows to create queries, mutations and field resolvers in an easy way - like a normal class methods, similar to REST controllers in frameworks like Java's <code>Spring</code>, .NET <code>Web API</code> or TypeScript's <a href="https://github.com/typestack/routing-controllers">routing-controllers</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="queries-and-mutations"></a><a href="#queries-and-mutations" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queries and mutations</h2>
<h3><a class="anchor" aria-hidden="true" id="resolvers-classes"></a><a href="#resolvers-classes" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolvers classes</h3>
<p>At first, you have to create a resolver class and annotate it with <code>@Resolver()</code> decorator. This class will behave like a controller known from classic REST frameworks:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {

}
</code></pre>
<p>You can use DI framework (as described in <a href="/type-graphql/docs/dependency-injection.html">dependency injection docs</a>) to inject class dependencies (like services or repositories) or store data inside resolvers class - it's guaranteed to be a single instance per app.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-keyword">private</span> recipesCollection: Recipe[] = [];
}
</code></pre>
<p>Then you can create class methods which will handle queries and mutations. For example let's add <code>recipes</code> query that will return a collection of all recipes:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-keyword">private</span> recipesCollection: Recipe[] = [];

  <span class="hljs-keyword">async</span> recipes() {
    <span class="hljs-comment">// fake async in this example</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.recipesCollection;
  }
}
</code></pre>
<p>We also need to do two things.
The first is to add <code>@Query</code> decorator (it marks the class method as the GraphQL's query).
The second is to provide the return type - the method is async so reflection metadata system shows that the return type is <code>Promise</code> of sth, so we have to add <code>returns =&gt; [Recipe]</code> decorator's parameter to declare that it will be an array of <code>Recipe</code> object types.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-keyword">private</span> recipesCollection: Recipe[] = [];

  <span class="hljs-meta">@Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [Recipe])
  <span class="hljs-keyword">async</span> recipes() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.recipesCollection;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="arguments"></a><a href="#arguments" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h3>
<p>Usually queries have some arguments - it might be an id of the resource, the search phrase or pagination settings. TypeGraphQL allows you to define the arguments in two ways.</p>
<p>First is the inline method using <code>@Arg()</code> decorator. The drawback is the need of repeating argument name (reflection system limitation) in decorator parameter.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-meta">@Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [Recipe])
  <span class="hljs-keyword">async</span> recipes(
    <span class="hljs-meta">@Arg</span>(<span class="hljs-string">"title"</span> { nullable: <span class="hljs-literal">true</span> }) title?: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span>&lt;Recipe[]&gt; {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>It's quite good when there are up to 2-3 args but when you have many more, the resolver's method definitions becomes bloated. In that case you can use the args class definition. It looks like the object type class but it has <code>@ArgsType()</code> decorator on top.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@ArgsType</span>()
<span class="hljs-keyword">class</span> GetRecipesArgs {
  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  skip?: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  take?: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@Field</span>({ nullable: <span class="hljs-literal">true</span> })
  title?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>You can define default values for optional fields (remember about <code>nullable: true</code>!) as well as helper methods.
Also, this way of declaring arguments allows you to perform its validation - more details about this feature you can find in <a href="/type-graphql/docs/validation.html">validation docs</a>.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@ArgsType</span>()
<span class="hljs-keyword">class</span> GetRecipesArgs {
  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">0</span>)
  skip = <span class="hljs-number">0</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Int, { nullable: <span class="hljs-literal">true</span> })
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">1</span>) <span class="hljs-meta">@Max</span>(<span class="hljs-number">50</span>)
  take = <span class="hljs-number">25</span>;

  <span class="hljs-meta">@Field</span>({ nullable: <span class="hljs-literal">true</span> })
  title?: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// helpers - index calculations</span>
  startIndex = skip;
  endIndex = skip + take;
}
</code></pre>
<p>Then all that left to do is to use the args class as the type of the method parameter.
We can use the destruction syntax to have access to single arguments as variables, instead of the reference to the whole args object.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-meta">@Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [Recipe])
  <span class="hljs-keyword">async</span> recipes(<span class="hljs-meta">@Args</span>() { title, startIndex, endIndex }: GetRecipesArgs) {
    <span class="hljs-comment">// sample implementation</span>
    <span class="hljs-keyword">let</span> recipes = <span class="hljs-keyword">this</span>.recipesCollection;
    <span class="hljs-keyword">if</span> (title) {
      recipes = recipes.filter(<span class="hljs-function"><span class="hljs-params">recipe</span> =&gt;</span> recipe.title === title)
    }
    <span class="hljs-keyword">return</span> recipes.slice(startIndex, endIndex);
  }
}
</code></pre>
<p>This declarations will result in the following part of the schema in SDL:</p>
<pre><code class="hljs css graphql"><span class="hljs-keyword">type</span> <span class="hljs-type">Query</span> {
  recipes(skip: <span class="hljs-type">Int</span>, take: <span class="hljs-type">Int</span>, title: <span class="hljs-type">String</span>): [<span class="hljs-type">Recipe</span>!]
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="input-types"></a><a href="#input-types" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Input types</h3>
<p>GraphQL's mutations we can create analogously, by declaring the class method, using <code>@Mutation</code> decorator, providing return type (if needed), creating arguments, etc. But for mutation we usually use <code>input</code> types, hence TypeGraphQL allows you to create inputs in the same way as the <a href="/type-graphql/docs/types-and-fields.html">object types</a> but using <code>@InputType()</code> decorator:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@InputType</span>()
<span class="hljs-keyword">class</span> AddRecipeInput {

}
</code></pre>
<p>We can also leverage TypeScript type checking system and ensure that we won't accidentally change the type of property by implementing <code>Partial</code> type:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@InputType</span>()
<span class="hljs-keyword">class</span> AddRecipeInput <span class="hljs-keyword">implements</span> Partial&lt;Recipe&gt; {
  
}
</code></pre>
<p>Then we can declare all the input fields we would need, using <code>@Field()</code> decorator:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@InputType</span>({ description: <span class="hljs-string">"New recipe data"</span> })
<span class="hljs-keyword">class</span> AddRecipeInput <span class="hljs-keyword">implements</span> Partial&lt;Recipe&gt; {
  <span class="hljs-meta">@Field</span>()
  title: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>({ nullable: <span class="hljs-literal">true</span> })
  description?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>After that we can use the <code>AddRecipeInput</code> type in our mutation. We can do this inline (using <code>@Arg()</code> decorator) or as a field of the args class like in query's example above.</p>
<p>We might also need access to the context. To achieve this we use <code>@Ctx()</code> decorator with optional user-defined <code>Context</code> interface:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>()
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-meta">@Mutation</span>()
  addRecipe(
    <span class="hljs-meta">@Arg</span>(<span class="hljs-string">"data"</span>) newRecipeData: AddRecipeInput,
    <span class="hljs-meta">@Ctx</span>() ctx: Context,
  ): Recipe {
    <span class="hljs-comment">// sample implementation</span>
    <span class="hljs-keyword">const</span> recipe = RecipesUtils.create(newRecipeData, ctx.user);
    <span class="hljs-keyword">this</span>.recipesCollection.push(recipe);
    <span class="hljs-keyword">return</span> recipe;
  }
}
</code></pre>
<p>Because our method is synchronous and explicitly returns <code>Recipe</code>, we can omit <code>@Mutation()</code> type annotation.</p>
<p>This declarations will result in the following parts of the schema in SDL:</p>
<pre><code class="hljs css graphql"><span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">AddRecipeInput</span> {
  <span class="hljs-attribute">title</span>: String!
  description: String
}
</code></pre>
<pre><code class="hljs css graphql"><span class="hljs-keyword">type</span> <span class="hljs-type">Query</span> {
  addRecipe(data: <span class="hljs-type">AddRecipeInput</span>!): <span class="hljs-type">Recipe</span>!
}
</code></pre>
<p>By using parameter decorators, we can get rid of the unnecessary parameters like root value that bloat our method definition and have to be ignored with <code>_</code> parameter name. Also, we can achieve clean separation between GraphQL and our business code with decorators abstraction, so our resolvers and their methods behave just like services which we can easily unit-test.</p>
<h2><a class="anchor" aria-hidden="true" id="field-resolvers"></a><a href="#field-resolvers" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Field resolvers</h2>
<p>Queries and mutations are not the only type of resolvers. We often create object type's field resolvers, e.g. when <code>user</code> type has field <code>posts</code> which we have to resolve by fetching relation data from the database.</p>
<p>Field resolvers in TypeGraphQL are very similar to queries and mutations - we create them as method of the resolver class but with a few modification. Firstly, we need to declare which object type's fields we are resolving by providing the type to <code>@Resolver</code> decorator:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// queries and mutations</span>
}
</code></pre>
<p>Then we can create the class method that become field resolver.
In our example we have <code>averageRating</code> field in <code>Recipe</code> object type that should calculate the average from the <code>ratings</code> array.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// queries and mutations</span>

  averageRating(recipe: Recipe) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>We need to mark the method as field resolver with <code>@FieldResolver()</code> decorator. Because we've defined the type of the field in <code>Recipe</code> class definition, there's no need to do this again. We also need to decorate the method's parameters with <code>@Root</code> to inject the recipe object.</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver {
  <span class="hljs-comment">// queries and mutations</span>

  <span class="hljs-meta">@FieldResolver</span>()
  averageRating(<span class="hljs-meta">@Root</span>() recipe: Recipe) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>For enhanced type-safe you can implement the <code>ResolverInterface&lt;Recipe&gt;</code>.
It's a small helper that will check if the return type of e.g. <code>averageRating</code> method is matching the <code>averageRating</code> property of the <code>Recipe</code> class
and whether the first parameter of the method is the object type (<code>Recipe</code> class).</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver <span class="hljs-keyword">implements</span> ResolverInterface&lt;Recipe&gt; {
  <span class="hljs-comment">// queries and mutations</span>

  <span class="hljs-meta">@FieldResolver</span>()
  averageRating(<span class="hljs-meta">@Root</span>() recipe: Recipe) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>Example implementation of the <code>averageRating</code> field resolver:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver <span class="hljs-keyword">implements</span> ResolverInterface&lt;Recipe&gt; {
  <span class="hljs-comment">// queries and mutations</span>

  <span class="hljs-meta">@FieldResolver</span>()
  averageRating(<span class="hljs-meta">@Root</span>() recipe: Recipe) {
    <span class="hljs-keyword">const</span> ratingsSum = recipe.ratings.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> recipe.ratings.length
      ? ratingsSum / recipe.ratings.length
      : <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<p>For simple resolvers like <code>averageRating</code> calculation or deprecated fields that behave like aliases, you can create the field resolvers inline in object type's class definition:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@ObjectType</span>()
<span class="hljs-keyword">class</span> Recipe {
  <span class="hljs-meta">@Field</span>()
  id: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>()
  title: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>({ deprecationReason: <span class="hljs-string">"Use `title` instead"</span> })
  <span class="hljs-keyword">get</span> name(): <span class="hljs-built_in">string</span> { 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.title;
  }

  <span class="hljs-meta">@Field</span>()
  ratings: Rate[];

  <span class="hljs-meta">@Field</span>()
  author: User;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> Float, { nullable: <span class="hljs-literal">true</span> })
  averageRating(<span class="hljs-meta">@Arg</span>(<span class="hljs-string">"since"</span>) sinceDate: <span class="hljs-built_in">Date</span>): <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">const</span> ratings = <span class="hljs-keyword">this</span>.ratings.filter(<span class="hljs-function"><span class="hljs-params">rate</span> =&gt;</span> rate.date &gt; sinceDate);
    <span class="hljs-keyword">if</span> (!ratings.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> ratingsSum = ratings.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> ratingsSum / ratings.length;
  };
}
</code></pre>
<p>However, use this way of creating field resolvers only if the implementation is simple.
If the code is more complicated and perform side effects (api call, db fetching), use resolver class's method instead - you can leverage dependency injection mechanism, really helpful in testing:</p>
<pre><code class="hljs css ts"><span class="hljs-meta">@Resolver</span>(<span class="hljs-function"><span class="hljs-params">objectType</span> =&gt;</span> Recipe)
<span class="hljs-keyword">class</span> RecipeResolver <span class="hljs-keyword">implements</span> ResolverInterface&lt;Recipe&gt; {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> userRepository: Repository&lt;User&gt;, <span class="hljs-comment">// dependency injection</span>
  </span>) {}

  <span class="hljs-meta">@FieldResolver</span>()
  <span class="hljs-keyword">async</span> author(<span class="hljs-meta">@Root</span>() recipe: Recipe) {
    <span class="hljs-keyword">const</span> author = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.userRepository.findById(recipe.userId);
    <span class="hljs-keyword">if</span> (!author) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SomethingWentWrongError();
    <span class="hljs-keyword">return</span> author;
  }
}
</code></pre>
<p>Note that if a field name of a field resolver doesn't exit in resolver object type, it will create in schema a field with this name. This feature is useful when the field is purely calculable (eg. <code>averageRating</code> from <code>ratings</code> array) and you don't want to pollute the class signature.</p>
<h2><a class="anchor" aria-hidden="true" id="resolvers-inheritance"></a><a href="#resolvers-inheritance" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolvers inheritance</h2>
<p>Inheritance of resolver classes is an advanced topic covered in <a href="/type-graphql/docs/interfaces-and-inheritance.html#resolvers-inheritance">interfaces and inheritance docs</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="examples"></a><a href="#examples" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h2>
<p>This code samples are made up just for tutorial docs purpose.
You can find more advanced, real examples in <a href="https://github.com/19majkel94/type-graphql/tree/master/examples">examples folder</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="types-and-fields.html">← Types and fields</a><a class="docs-next button" href="bootstrap.html">Bootstrapping →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#queries-and-mutations">Queries and mutations</a><ul class="toc-headings"><li><a href="#resolvers-classes">Resolvers classes</a></li><li><a href="#arguments">Arguments</a></li><li><a href="#input-types">Input types</a></li></ul></li><li><a href="#field-resolvers">Field resolvers</a></li><li><a href="#resolvers-inheritance">Resolvers inheritance</a></li><li><a href="#examples">Examples</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/type-graphql/" class="nav-home"><img src="/type-graphql/img/logo.png" alt="TypeGraphQL" width="66" height="58"/></a><div><h5>Docs</h5><a href="/type-graphql/docs/en/introduction.html">Introduction</a><a href="/type-graphql/docs/en/getting-started.html">Getting Started</a><a href="/type-graphql/docs/en/scalars.html">Advanced Guides</a></div><div><h5>Community</h5><a href="https://github.com/19majkel94/type-graphql/issues?utf8=✓&amp;q=is%3Aissue+label%3A&amp;quot;Enhancement+%3Anew%3A&amp;quot;+">Feature requests and proposals</a><a href="https://github.com/19majkel94/type-graphql/issues?q=is%3Aissue+label%3A&amp;quot;Bug+%3Abug%3A&amp;quot;">Issues</a><a href="https://gitter.im/type-graphql/Lobby">Project Chat</a><a href="https://twitter.com/19majkel94" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/type-graphql/blog">Blog</a><a href="https://github.com/19majkel94/type-graphql">GitHub</a><a class="github-button" href="https://github.com/19majkel94/type-graphql" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2018 Michał Lytek</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-117093147-1', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                
                apiKey: '2cf66434100c0e30ca9ff499830e7b77',
                indexName: 'typegraphql',
                inputSelector: '#search_input_react'
              });
            </script></body></html>